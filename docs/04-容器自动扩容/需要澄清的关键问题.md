# Step 4 - 容器自动扩容：需要澄清的关键问题

## 文档用途
本文档列出实现"容器自动扩容"功能前**必须澄清**的技术问题，避免基于错误假设进行开发。

---

## 🔴 高优先级问题（必须验证）

### Q1: X6 子节点的 `getBBox()` 返回值是什么坐标系？

**背景**：  
- 已知：`node.getPosition()` 返回绝对坐标（已验证）
- 未知：`node.getBBox()` 返回的 `{ x, y, width, height }` 中的 `x/y` 是相对还是绝对？

**验证方法**：
```typescript
const container = graph.addNode({
  shape: 'rect',
  x: 100,
  y: 100,
  width: 300,
  height: 300
})

const child = graph.addNode({
  shape: 'rect',
  x: 150,
  y: 150,
  width: 50,
  height: 50
})

container.addChild(child)

console.log('容器 position:', container.getPosition())  // { x: 100, y: 100 }
console.log('子节点 position:', child.getPosition())    // { x: 150, y: 150 }（已知是绝对坐标）
console.log('子节点 getBBox:', child.getBBox())        // { x: ?, y: ?, width: 50, height: 50 }
```

**期望答案**：
- [ ] A. `getBBox()` 返回 `{ x: 50, y: 50, ... }`（相对坐标：150-100=50）
- [ ] B. `getBBox()` 返回 `{ x: 150, y: 150, ... }`（绝对坐标）
- [ ] C. 其他情况（请描述）

**影响**：
- 如果是 **B（绝对坐标）**：文档第 5.3.1、5.3.2 节需要删除
- 如果是 **A（相对坐标）**：需要在扩容算法中转换坐标

---

### Q2: `Graph.getCellsBBox(cells)` 的坐标系是什么？

**背景**：  
扩容算法依赖 `Graph.getCellsBBox()` 计算子节点的并集包围盒，但其返回值的坐标系定义不明确。

**验证方法**：
```typescript
const container = graph.addNode({
  shape: 'rect',
  x: 100,
  y: 100,
  width: 500,
  height: 500
})

const child1 = graph.addNode({ shape: 'rect', x: 150, y: 150, width: 50, height: 50 })
const child2 = graph.addNode({ shape: 'rect', x: 250, y: 250, width: 50, height: 50 })

container.addChild(child1)
container.addChild(child2)

const unionBBox = Graph.getCellsBBox([child1, child2])
console.log('并集包围盒:', unionBBox)
// 预期 width: 150, height: 150
// 预期 x/y: ??? (150 还是 50？)
```

**期望答案**：
- [ ] A. 返回相对于容器的坐标：`{ x: 50, y: 50, width: 150, height: 150 }`
- [ ] B. 返回绝对坐标：`{ x: 150, y: 150, width: 150, height: 150 }`
- [ ] C. 其他情况（请描述）

**影响**：
- 决定位置调整算法（文档第 6.3.2 节）的正确性
- 如果返回绝对坐标，需要计算：`offsetX = (unionBBox.x - containerPos.x) - PADDING`

---

### Q3: 容器位置调整后，子节点是否自动跟随？

**背景**：  
X6 的 embedded 机制理论上应该让子节点跟随父节点移动，但需要验证具体行为。

**验证方法**：
```typescript
const container = graph.addNode({ x: 100, y: 100, width: 300, height: 300 })
const child = graph.addNode({ x: 150, y: 150, width: 50, height: 50 })
container.addChild(child)

console.log('调整前 - 容器:', container.getPosition())  // { x: 100, y: 100 }
console.log('调整前 - 子节点:', child.getPosition())    // { x: 150, y: 150 }

// 将容器移动到新位置
container.setPosition({ x: 80, y: 80 })

console.log('调整后 - 容器:', container.getPosition())  // { x: 80, y: 80 }
console.log('调整后 - 子节点:', child.getPosition())    // { x: ?, y: ? }
```

**期望答案**：
- [ ] A. 子节点自动跟随：`{ x: 130, y: 130 }`（偏移量 -20）
- [ ] B. 子节点坐标不变：`{ x: 150, y: 150 }`（视觉上"飞出"容器）
- [ ] C. 其他情况（请描述）

**影响**：
- 如果是 **B**：扩容算法在调整容器位置后，必须手动更新所有子节点坐标
- 如果是 **A**：无需额外处理

---

### Q4: `container.resize()` 的锚点在哪里？

**背景**：  
执行 `resize(newWidth, newHeight)` 时，容器的哪个点保持不变？

**验证方法**：
```typescript
const container = graph.addNode({ x: 100, y: 100, width: 200, height: 200 })

console.log('调整前 position:', container.getPosition())  // { x: 100, y: 100 }

container.resize(300, 300)

console.log('调整后 position:', container.getPosition())  // { x: ?, y: ? }
console.log('调整后 size:', container.getSize())        // { width: 300, height: 300 }
```

**期望答案**：
- [ ] A. 左上角不变：`position` 仍是 `{ x: 100, y: 100 }`
- [ ] B. 中心点不变：`position` 变为 `{ x: 50, y: 50 }`
- [ ] C. 其他情况（请描述）

**影响**：
- 如果是 **B（中心不变）**：需要在 resize 后补偿位置调整
- 如果是 **A（左上角不变）**：符合当前文档假设

---

## 🟡 中优先级问题（业务需求确认）

### Q5: 期望的扩容视觉效果是什么？

**场景**：  
容器在 (100, 100)，子节点在 (150, 150) 和 (250, 250)，触发扩容。

**选项 A - 容器左上角固定**：
```
调整前：
  容器: x=100, y=100, width=300, height=300
  子节点: x=150, y=150 和 x=250, y=250

调整后：
  容器: x=100, y=100, width=新宽度, height=新高度
  子节点: 坐标不变，但视觉上可能不在容器中心
```

**选项 B - 容器包裹子节点（当前文档方案）**：
```
调整后：
  容器: x=110, y=110, width=新宽度, height=新高度
  （容器左上角 = 子节点最小 x/y - PADDING）
  子节点: 视觉位置不变，保持在容器中心
```

**选项 C - 容器中心固定**：
```
调整后：
  容器: 中心点不变，四周扩展
  子节点: 视觉位置不变
```

**请选择**：
- [ ] A. 容器左上角固定
- [ ] B. 容器包裹子节点（紧贴 + PADDING）
- [ ] C. 容器中心固定
- [ ] D. 其他（请描述）

---

### Q6: 空容器的行为规范

**场景 1：新建空容器**
从 Stencil 拖入一个系统容器，此时没有子节点。

**问题**：
- 初始尺寸是？（当前文档：200x150）
- 位置如何确定？（当前假设：拖放点）

**场景 2：删除所有子节点**
容器原本有 3 个子节点，用户全部删除。

**问题**：
- 容器是否恢复最小尺寸？（当前文档：是）
- 容器位置是否变化？（当前文档：未说明）

**期望行为**：
- [ ] A. 恢复最小尺寸，位置不变
- [ ] B. 恢复最小尺寸，位置移至原中心点
- [ ] C. 保持当前尺寸和位置（不缩小）
- [ ] D. 其他（请描述）

---

### Q7: 是否需要最大尺寸限制？

**场景**：  
容器内有 10 个子节点，分布极度分散（跨越 2000px x 1500px）。

**问题**：
- 容器是否应该无限制扩容包裹所有子节点？
- 是否设置最大尺寸（如 1500x1000），超出部分允许外溢？

**选项**：
- [ ] A. 无限制扩容（当前文档方案）
- [ ] B. 限制最大尺寸为 `{ width: ____, height: ____ }`
- [ ] C. 动态计算合理上限（如画布尺寸的 80%）
- [ ] D. 其他（请描述）

---

## 🟢 低优先级问题（体验优化）

### Q8: 防抖延迟是否可接受？

**当前配置**：100ms

**用户体验**：
- 拖动子节点时，容器会延迟 100ms 后才开始扩容
- 快速拖动多个节点时，可能产生"批量扩容"的跳变效果

**问题**：
- [ ] A. 100ms 可接受，保持当前配置
- [ ] B. 改为 50ms（更灵敏，但计算次数增加）
- [ ] C. 改为 200ms（减少计算，但延迟更明显）
- [ ] D. 让用户可配置

---

### Q9: 容器移动时是否触发扩容检查？

**场景**：  
用户直接拖动容器（而非子节点）。

**当前文档方案**：不触发扩容（使用标志位跳过）

**替代方案**：
- [ ] A. 保持当前方案（容器移动不触发扩容）
- [ ] B. 检查子节点是否外溢，仅在外溢时扩容
- [ ] C. 每次容器移动都重新计算扩容
- [ ] D. 其他（请描述）

---

### Q10: 是否需要扩容动画？

**当前文档**：提到可选 CSS 过渡动画 0.2s

**问题**：
- [ ] A. 不需要动画，瞬间完成（性能最优）
- [ ] B. 添加平滑过渡动画（duration: 200ms）
- [ ] C. 让用户可配置
- [ ] D. 其他（请描述）

**注意**：如果添加动画，需要考虑：
- 动画期间是否禁止扩容触发？
- 子节点位置是否同步跟随动画？

---

## 验证流程建议

### 第一步：创建最小验证 Demo
```typescript
// demo.ts - 在独立的测试页面运行
import { Graph } from '@antv/x6'

const graph = new Graph({
  container: document.getElementById('container'),
  width: 800,
  height: 600
})

// Q1 验证：getBBox() 坐标系
const container = graph.addNode({ x: 100, y: 100, width: 300, height: 300 })
const child = graph.addNode({ x: 150, y: 150, width: 50, height: 50 })
container.addChild(child)
console.log('Q1 - getBBox:', child.getBBox())

// Q2 验证：getCellsBBox() 坐标系
const child2 = graph.addNode({ x: 250, y: 250, width: 50, height: 50 })
container.addChild(child2)
console.log('Q2 - getCellsBBox:', Graph.getCellsBBox([child, child2]))

// Q3 验证：子节点跟随行为
const beforeMove = child.getPosition()
container.setPosition({ x: 80, y: 80 })
const afterMove = child.getPosition()
console.log('Q3 - 子节点是否跟随:', { beforeMove, afterMove })

// Q4 验证：resize 锚点
const beforeResize = container.getPosition()
container.resize(400, 400)
const afterResize = container.getPosition()
console.log('Q4 - resize 锚点:', { beforeResize, afterResize })
```

### 第二步：记录验证结果
将上述 demo 的输出结果填入本文档的"期望答案"部分。

### 第三步：更新方案文档
根据验证结果，修正 `04-容器自动扩容.md` 中的错误假设，重新设计扩容算法。

---

## 注意事项

### ⚠️ 禁止行为
- ❌ 在未验证 Q1-Q4 前开始编写扩容算法代码
- ❌ 基于"应该是这样"的假设实现功能
- ❌ 复制可行性分析文档中的示例代码（可能基于假设）

### ✅ 推荐行为
- ✅ 先查阅 X6 官方文档关于 `getBBox()`、`getCellsBBox()` 的说明
- ✅ 编写最小 demo 验证核心 API 行为
- ✅ 在代码注释中引用官方文档或验证结果
- ✅ 将验证过程的日志和截图保存，便于后续回溯

---

**文档版本**：1.0.0  
**创建时间**：2026-02-10  
**更新时间**：待验证完成后更新  
**状态**：⏸️ 等待验证结果
