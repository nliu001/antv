# Step 7 - 性能优化调优

## 目录
- [1. 步骤概述](#1-步骤概述)
- [2. 目标与产出](#2-目标与产出)
- [3. 性能指标](#3-性能指标)
- [4. 实现任务拆解](#4-实现任务拆解)
- [5. 渲染性能优化](#5-渲染性能优化)
- [6. 计算性能优化](#6-计算性能优化)
- [7. 内存优化](#7-内存优化)
- [8. 监控与分析](#8-监控与分析)
- [9. 测试要点](#9-测试要点)
- [10. 验收标准](#10-验收标准)
- [11. 注意事项](#11-注意事项)

---

## 1. 步骤概述

### 1.1 当前步骤定位
这是图形化布局系统的**最后一步**，进行全面的性能优化和调优。本步骤将识别性能瓶颈，实施针对性优化措施，并建立性能监控体系，确保系统在各种场景下保持流畅运行。

### 1.2 前置依赖
- ✅ Step 1-6：所有功能已实现
- ✅ 系统已进入可用状态
- ✅ 有真实场景测试数据

### 1.3 优化目标
```
当前性能 → 性能分析 → 针对性优化 → 达到目标性能
```

---

## 2. 目标与产出

### 2.1 性能目标
- ✅ 画布初始化时间 < 2s
- ✅ 500 节点场景保持 60 FPS
- ✅ 1000 节点场景保持 30 FPS
- ✅ 拖拽操作延迟 < 16ms
- ✅ 容器扩容计算 < 100ms
- ✅ 布局算法执行 < 2s（100 节点）
- ✅ 内存占用 < 200MB（500 节点）
- ✅ 无内存泄漏

### 2.2 交付产出
1. **优化实现**
   - 渲染优化
   - 计算优化
   - 内存优化
   - 事件优化

2. **监控工具**
   - `src/utils/performanceMonitor.ts` - 性能监控工具
   - `src/utils/memoryTracker.ts` - 内存追踪工具

3. **配置文件**
   - `src/config/performanceConfig.ts` - 性能配置

4. **文档**
   - 性能测试报告
   - 优化措施清单
   - 最佳实践指南

---

## 3. 性能指标

### 3.1 关键指标（KPI）

#### 3.1.1 渲染性能
- **FPS（帧率）**
  - 目标：60 FPS（理想）
  - 底线：30 FPS（可接受）
  - 测量：使用 `requestAnimationFrame` 计算

- **首屏加载时间**
  - 目标：< 2s
  - 测量：从页面加载到画布可交互

- **节点渲染时间**
  - 单节点：< 50ms
  - 100 节点：< 2s
  - 500 节点：< 5s

#### 3.1.2 交互性能
- **拖拽响应时间**
  - 目标：< 16ms（60 FPS 单帧时间）
  - 测量：从鼠标移动到节点位置更新

- **缩放响应时间**
  - 目标：< 50ms
  - 测量：从滚轮事件到视图更新

- **点击响应时间**
  - 目标：< 100ms
  - 测量：从点击到弹窗显示

#### 3.1.3 计算性能
- **包围盒计算**
  - 10 节点：< 10ms
  - 50 节点：< 50ms
  - 100 节点：< 100ms

- **布局算法执行**
  - 50 节点：< 500ms
  - 100 节点：< 2s
  - 200 节点：< 5s

#### 3.1.4 内存性能
- **内存占用**
  - 空画布：< 50MB
  - 100 节点：< 100MB
  - 500 节点：< 200MB

- **内存泄漏**
  - 目标：0 泄漏
  - 测量：反复操作后内存不持续增长

---

## 4. 实现任务拆解

### 4.1 任务清单
| 任务编号 | 任务名称 | 优先级 | 预估工时 | 依赖 |
|---------|---------|--------|----------|------|
| T7-1 | 建立性能基准测试 | P0 | 2h | 无 |
| T7-2 | 实现性能监控工具 | P0 | 2h | T7-1 |
| T7-3 | 优化 Vue 组件渲染 | P0 | 3h | T7-2 |
| T7-4 | 优化 X6 事件处理 | P0 | 2.5h | T7-2 |
| T7-5 | 优化容器扩容计算 | P0 | 2h | T7-2 |
| T7-6 | 优化布局算法 | P1 | 3h | T7-2 |
| T7-7 | 实现虚拟滚动（可选） | P2 | 4h | T7-3 |
| T7-8 | 内存泄漏检测与修复 | P0 | 3h | T7-2 |
| T7-9 | 代码分割与懒加载 | P1 | 2h | 无 |
| T7-10 | 编写性能测试报告 | P0 | 2h | T7-9 |

**总工时**：约 25.5 小时（3.5 个工作日）

### 4.2 实施顺序
```
Phase 1: 测量基准 (T7-1, T7-2)
    ↓
Phase 2: 渲染优化 (T7-3, T7-4)
    ↓
Phase 3: 计算优化 (T7-5, T7-6)
    ↓
Phase 4: 内存优化 (T7-7, T7-8)
    ↓
Phase 5: 工程优化 (T7-9, T7-10)
```

---

## 5. 渲染性能优化

### 5.1 Vue 组件优化

#### 5.1.1 使用 markRaw
避免 Vue 对 Graph 实例深度监听：
```typescript
import { markRaw } from 'vue'

const graph = markRaw(new Graph({ ... }))
```

#### 5.1.2 使用 v-once
对于静态内容使用 `v-once` 指令：
```vue
<template>
  <div v-once class="static-content">
    <!-- 不会变化的内容 -->
  </div>
</template>
```

#### 5.1.3 使用 v-memo
对于条件渲染使用 `v-memo`：
```vue
<template>
  <div v-memo="[node.id, node.status]">
    <!-- 仅在 id 或 status 变化时更新 -->
  </div>
</template>
```

#### 5.1.4 避免不必要的计算属性
将复杂计算移到 Composable 或工具函数：
```typescript
// ❌ 不好：每次渲染都计算
const complexValue = computed(() => {
  // 复杂计算
})

// ✅ 好：缓存结果
const complexValue = useMemoizedValue(() => {
  // 复杂计算
}, [dependency])
```

### 5.2 X6 渲染优化

#### 5.2.1 启用异步渲染
```typescript
const graph = new Graph({
  async: true,  // 启用异步渲染
  frozen: false  // 允许冻结渲染
})
```

#### 5.2.2 批量更新节点
```typescript
// ❌ 不好：逐个更新
nodes.forEach(node => {
  node.position(x, y)
})

// ✅ 好：批量更新
graph.freeze()  // 冻结渲染
nodes.forEach(node => {
  node.position(x, y)
})
graph.unfreeze()  // 恢复渲染
```

#### 5.2.3 使用虚拟渲染
仅渲染可视区域内的节点：
```typescript
const graph = new Graph({
  scroller: {
    enabled: true,
    pageVisible: true,  // 仅渲染可见区域
    pageBreak: false
  }
})
```

### 5.3 CSS 优化

#### 5.3.1 使用 CSS Transform
优先使用 `transform` 而非 `left/top`：
```css
/* ❌ 不好：触发重排 */
.node {
  left: 100px;
  top: 100px;
}

/* ✅ 好：仅触发重绘 */
.node {
  transform: translate(100px, 100px);
}
```

#### 5.3.2 使用 will-change
提示浏览器优化动画属性：
```css
.dragging-node {
  will-change: transform;
}
```

#### 5.3.3 避免昂贵的 CSS 属性
```css
/* ❌ 避免：昂贵的属性 */
box-shadow: 0 0 10px rgba(0,0,0,0.5);
filter: blur(5px);

/* ✅ 优先：高性能属性 */
transform: translateZ(0);
opacity: 0.8;
```

---

## 6. 计算性能优化

### 6.1 防抖与节流

#### 6.1.1 防抖（Debounce）
用于延迟执行，适合容器扩容：
```typescript
import { debounce } from 'lodash-es'

const expandContainer = debounce((container) => {
  // 扩容逻辑
}, 100)
```

#### 6.1.2 节流（Throttle）
用于限制频率，适合滚动事件：
```typescript
import { throttle } from 'lodash-es'

const handleScroll = throttle(() => {
  // 滚动处理
}, 100)
```

### 6.2 缓存计算结果

#### 6.2.1 包围盒缓存
```typescript
const bboxCache = new Map<string, BBox>()

function getCachedBBox(node: Node): BBox {
  const cacheKey = `${node.id}-${node.position().x}-${node.position().y}`
  
  if (!bboxCache.has(cacheKey)) {
    bboxCache.set(cacheKey, node.getBBox())
  }
  
  return bboxCache.get(cacheKey)!
}
```

#### 6.2.2 布局结果缓存
缓存布局算法结果，避免重复计算：
```typescript
const layoutCache = new Map<string, LayoutResult>()

function getCachedLayout(nodes: Node[], algorithm: string) {
  const cacheKey = `${algorithm}-${nodes.map(n => n.id).join(',')}`
  
  if (!layoutCache.has(cacheKey)) {
    layoutCache.set(cacheKey, executeLayout(nodes, algorithm))
  }
  
  return layoutCache.get(cacheKey)!
}
```

### 6.3 算法优化

#### 6.3.1 空间索引
使用四叉树等空间索引加速碰撞检测：
```typescript
import { Quadtree } from 'd3-quadtree'

const quadtree = Quadtree()
  .x(d => d.x)
  .y(d => d.y)
  .addAll(nodes)

// 快速查找范围内的节点
const nodesInRange = quadtree.find(x, y, radius)
```

#### 6.3.2 增量更新
仅更新变化的部分，而非全量重算：
```typescript
// ❌ 不好：全量重算
function updateAllNodes() {
  nodes.forEach(node => recalculate(node))
}

// ✅ 好：增量更新
function updateChangedNodes(changedNodes) {
  changedNodes.forEach(node => recalculate(node))
}
```

### 6.4 Web Worker

#### 6.4.1 异步布局计算
将布局算法放到 Web Worker 中执行：
```typescript
// worker.ts
self.onmessage = (e) => {
  const { nodes, edges, algorithm } = e.data
  const result = executeLayout(nodes, edges, algorithm)
  self.postMessage(result)
}

// main.ts
const worker = new Worker('./worker.ts')

worker.postMessage({ nodes, edges, algorithm })

worker.onmessage = (e) => {
  const result = e.data
  applyLayoutResult(result)
}
```

---

## 7. 内存优化

### 7.1 事件监听清理

#### 7.1.1 组件销毁时清理
```typescript
onBeforeUnmount(() => {
  // 清理 X6 事件监听
  graph.off('node:click')
  graph.off('node:dblclick')
  graph.off('node:change:position')
  
  // 销毁 Graph 实例
  graph.dispose()
  
  // 清空缓存
  bboxCache.clear()
  layoutCache.clear()
})
```

#### 7.1.2 避免闭包陷阱
```typescript
// ❌ 不好：闭包持有引用
graph.on('node:click', ({ node }) => {
  const data = node.getData()
  // data 持有 node 引用
})

// ✅ 好：及时释放引用
graph.on('node:click', ({ node }) => {
  const data = { ...node.getData() }  // 拷贝数据
})
```

### 7.2 避免内存泄漏

#### 7.2.1 定时器清理
```typescript
let timer: number | null = null

function startTimer() {
  timer = window.setTimeout(() => {
    // 逻辑
  }, 1000)
}

onBeforeUnmount(() => {
  if (timer) {
    clearTimeout(timer)
    timer = null
  }
})
```

#### 7.2.2 WeakMap 缓存
使用 WeakMap 避免内存泄漏：
```typescript
// ❌ 不好：Map 强引用
const cache = new Map<Node, BBox>()

// ✅ 好：WeakMap 弱引用
const cache = new WeakMap<Node, BBox>()
```

### 7.3 大对象优化

#### 7.3.1 分页加载
大量节点时分页加载：
```typescript
async function loadNodesInBatches(nodes: Node[], batchSize = 50) {
  for (let i = 0; i < nodes.length; i += batchSize) {
    const batch = nodes.slice(i, i + batchSize)
    
    graph.freeze()
    batch.forEach(node => graph.addNode(node))
    graph.unfreeze()
    
    // 让出主线程
    await new Promise(resolve => setTimeout(resolve, 0))
  }
}
```

#### 7.3.2 虚拟列表
物料面板使用虚拟列表：
```vue
<template>
  <VirtualList
    :items="stencilItems"
    :item-size="80"
    :buffer="5"
  >
    <template #default="{ item }">
      <StencilItem :data="item" />
    </template>
  </VirtualList>
</template>
```

---

## 8. 监控与分析

### 8.1 性能监控工具

#### 8.1.1 FPS 监控
```typescript
class FPSMonitor {
  private frames = 0
  private lastTime = performance.now()
  private fps = 0

  start() {
    const tick = () => {
      const now = performance.now()
      this.frames++
      
      if (now >= this.lastTime + 1000) {
        this.fps = Math.round((this.frames * 1000) / (now - this.lastTime))
        this.frames = 0
        this.lastTime = now
        
        console.log(`FPS: ${this.fps}`)
      }
      
      requestAnimationFrame(tick)
    }
    
    requestAnimationFrame(tick)
  }

  getFPS() {
    return this.fps
  }
}
```

#### 8.1.2 内存监控
```typescript
function logMemoryUsage() {
  if (performance.memory) {
    const { usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit } = performance.memory
    
    console.log({
      used: `${(usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
      total: `${(totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
      limit: `${(jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`
    })
  }
}
```

### 8.2 性能分析

#### 8.2.1 性能标记
```typescript
performance.mark('layout-start')

// 执行布局
executeLayout()

performance.mark('layout-end')
performance.measure('layout-duration', 'layout-start', 'layout-end')

const measure = performance.getEntriesByName('layout-duration')[0]
console.log(`布局耗时: ${measure.duration.toFixed(2)}ms`)
```

#### 8.2.2 Chrome DevTools
- **Performance 面板**：记录并分析性能
- **Memory 面板**：检测内存泄漏
- **Rendering 面板**：显示 FPS 和重绘区域

---

## 9. 测试要点

### 9.1 性能测试
- [ ] 测试 100/500/1000 节点场景的 FPS
- [ ] 测试拖拽响应时间
- [ ] 测试布局算法执行时间
- [ ] 测试内存占用
- [ ] 测试内存泄漏

### 9.2 压力测试
- [ ] 连续拖拽 1 分钟不卡顿
- [ ] 连续缩放 1 分钟不卡顿
- [ ] 反复添加删除节点无内存泄漏

### 9.3 兼容性测试
- [ ] Chrome 性能正常
- [ ] Firefox 性能正常
- [ ] Edge 性能正常

---

## 10. 验收标准

### 10.1 性能验收
- ✅ 500 节点场景 FPS ≥ 30
- ✅ 拖拽延迟 < 16ms
- ✅ 布局算法执行 < 2s
- ✅ 内存占用 < 200MB
- ✅ 无内存泄漏

### 10.2 代码质量验收
- ✅ 通过性能测试
- ✅ 有性能监控工具
- ✅ 有性能测试报告

---

## 11. 注意事项

### 11.1 优化原则
- 先测量，后优化
- 优化 20% 的热点代码
- 避免过早优化

### 11.2 平衡取舍
- 性能 vs 可维护性
- 性能 vs 功能丰富度
- 性能 vs 开发成本

---

**文档版本**：1.0.0  
**创建时间**：2026-02-09  
**预估工时**：3.5 天  
**优先级**：P1（重要）
