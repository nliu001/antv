# Step 5 - 布局算法集成

## 目录
- [1. 步骤概述](#1-步骤概述)
- [2. 目标与产出](#2-目标与产出)
- [3. 技术方案](#3-技术方案)
- [4. 实现任务拆解](#4-实现任务拆解)
- [5. 布局算法设计](#5-布局算法设计)
- [6. 局部整理实现](#6-局部整理实现)
- [7. 锁定机制设计](#7-锁定机制设计)
- [8. 工具栏集成](#8-工具栏集成)
- [9. 测试要点](#9-测试要点)
- [10. 验收标准](#10-验收标准)
- [11. 注意事项](#11-注意事项)

---

## 1. 步骤概述

### 1.1 当前步骤定位
这是图形化布局系统的**第五步**，集成自动化布局算法，支持用户在手动布局基础上使用算法快速整理节点位置。本步骤实现 Dagre（层级布局）和 Grid（网格布局）两种算法，并提供局部整理和锁定机制。

### 1.2 前置依赖
- ✅ Step 1-4：基础画布、节点、拖拽、扩容已完成
- ✅ 需要安装 `@antv/layout` 依赖
- ✅ 节点数据模型支持 `isManual` 标记

### 1.3 后续依赖关系
```
Step 4 (容器扩容)
    ↓
Step 5 (布局算法) ← 当前步骤
    ↓ 提供自动整理能力
Step 6 (业务集成) - 业务数据可能影响布局
```

---

## 2. 目标与产出

### 2.1 功能目标
- ✅ 集成 Dagre 层级布局算法
- ✅ 集成 Grid 网格布局算法
- ✅ 支持全局布局（整个画布）
- ✅ 支持局部布局（仅对选中容器内部）
- ✅ 实现锁定机制（isManual 标记）
- ✅ 在工具栏添加布局触发按钮
- ✅ 布局执行后自动触发容器扩容
- ✅ 提供布局前后对比（可选）

### 2.2 交付产出
1. **Composable 文件**
   - `src/composables/useLayout.ts` - 布局算法管理

2. **工具文件**
   - `src/utils/layoutAlgorithms.ts` - 布局算法封装
   - `src/utils/layoutAdapter.ts` - 数据格式适配器

3. **配置文件**
   - `src/config/layoutConfig.ts` - 布局算法配置

4. **组件扩展**
   - 扩展 `Toolbar.vue` - 添加布局按钮

5. **类型定义**
   - 扩展 `src/types/layout.d.ts` - 布局相关类型

---

## 3. 技术方案

### 3.1 技术选型
| 技术项 | 方案 | 理由 |
|--------|------|------|
| 布局引擎 | @antv/layout | AntV 官方布局算法库 |
| Dagre 算法 | DagreLayout | 有向无环图布局 |
| Grid 算法 | GridLayout | 网格对齐布局 |
| 数据适配 | 自定义 Adapter | X6 数据格式转换 |

### 3.2 架构设计
```
Toolbar Button (触发布局)
    ↓
useLayout (选择算法)
    ↓
layoutAdapter (数据转换)
    ↓
@antv/layout (执行算法)
    ↓
应用新坐标到节点
    ↓
触发容器扩容
    ↓
视图更新
```

### 3.3 布局执行流程
```
1. 用户点击布局按钮
    ↓
2. 确定布局范围（全局/局部）
    ↓
3. 过滤锁定节点（isManual: true）
    ↓
4. 收集节点和边数据
    ↓
5. 转换为布局引擎格式
    ↓
6. 执行布局算法
    ↓
7. 获取新坐标
    ↓
8. 应用新坐标到节点
    ↓
9. 触发容器扩容
    ↓
10. 记录布局历史（可撤销）
```

---

## 4. 实现任务拆解

### 4.1 任务清单
| 任务编号 | 任务名称 | 优先级 | 预估工时 | 依赖 |
|---------|---------|--------|----------|------|
| T5-1 | 安装 @antv/layout 依赖 | P0 | 0.5h | 无 |
| T5-2 | 创建布局配置文件 | P0 | 1h | 无 |
| T5-3 | 实现数据适配器 | P0 | 2h | 无 |
| T5-4 | 封装 Dagre 布局算法 | P0 | 2h | T5-3 |
| T5-5 | 封装 Grid 布局算法 | P0 | 1.5h | T5-3 |
| T5-6 | 实现 useLayout Composable | P0 | 2.5h | T5-4, T5-5 |
| T5-7 | 实现锁定机制 | P0 | 1.5h | T5-6 |
| T5-8 | 实现局部布局功能 | P0 | 2h | T5-6 |
| T5-9 | 扩展工具栏布局按钮 | P0 | 1.5h | T5-6 |
| T5-10 | 集成容器扩容触发 | P0 | 1h | T5-8 |
| T5-11 | 测试布局功能 | P0 | 2h | T5-10 |

**总工时**：约 17.5 小时（2.5 个工作日）

### 4.2 实施顺序
```
Phase 1: 环境准备 (T5-1, T5-2)
    ↓
Phase 2: 算法封装 (T5-3, T5-4, T5-5)
    ↓
Phase 3: 核心逻辑 (T5-6, T5-7, T5-8)
    ↓
Phase 4: UI 集成 (T5-9, T5-10)
    ↓
Phase 5: 测试验证 (T5-11)
```

---

## 5. 布局算法设计

### 5.1 Dagre 布局

#### 5.1.1 算法特点
- **适用场景**：有向图、流程图、拓扑图
- **布局方向**：支持 TB（上到下）、LR（左到右）等
- **层级分明**：节点按照依赖关系分层
- **边不交叉**：尽量减少连接线交叉

#### 5.1.2 配置参数
```typescript
const dagreConfig = {
  type: 'dagre',
  
  // 布局方向
  rankdir: 'TB',  // TB | BT | LR | RL
  
  // 节点对齐方式
  align: 'UL',    // UL | UR | DL | DR
  
  // 节点间距
  nodesep: 40,    // 同层节点间距
  ranksep: 60,    // 层级间距
  
  // 边控制点
  controlPoints: true,
  
  // 排序函数（可选）
  sortByCombo: false
}
```

#### 5.1.3 使用场景
- 设备间有连接关系
- 需要展示数据流向
- 逻辑层级清晰

### 5.2 Grid 布局

#### 5.2.1 算法特点
- **适用场景**：无连接关系、平铺展示
- **布局方式**：网格对齐、均匀分布
- **整齐美观**：行列对齐、间距统一
- **易于浏览**：适合大量节点展示

#### 5.2.2 配置参数
```typescript
const gridConfig = {
  type: 'grid',
  
  // 起始位置
  begin: [50, 50],
  
  // 是否按行排列
  sortBy: 'row',  // row | col
  
  // 列数（可选，不设置则自动计算）
  cols: undefined,
  
  // 行数（可选）
  rows: undefined,
  
  // 节点间距
  nodeSize: [120, 80],
  nodeSpacing: [40, 40],  // [水平间距, 垂直间距]
  
  // 是否防止重叠
  preventOverlap: true
}
```

#### 5.2.3 使用场景
- 设备无连接关系
- 需要整齐排列
- 容器内部整理

### 5.3 其他布局（可选扩展）

#### 5.3.1 Force（力导向布局）
- 适合复杂网络
- 节点自动聚类
- 视觉效果好但计算量大

#### 5.3.2 Circular（环形布局）
- 适合周期性结构
- 节点排列成圆形
- 节省空间

---

## 6. 局部整理实现

### 6.1 功能需求

#### 6.1.1 全局布局
- 对整个画布上的所有节点执行布局
- 排除锁定的节点
- 不干扰容器内部结构

#### 6.1.2 局部布局
- 仅对选中容器内部的子节点执行布局
- 不影响容器外的节点
- 容器位置不变

### 6.2 实现方案

#### 6.2.1 检测布局范围
```typescript
function getLayoutScope(): 'global' | 'local' {
  const selectedNodes = graph.getSelectedCells({ 
    filter: (cell) => cell.isNode() 
  })
  
  // 如果选中了一个容器节点，执行局部布局
  if (
    selectedNodes.length === 1 &&
    selectedNodes[0].getData()?.type === NodeType.SYSTEM
  ) {
    return 'local'
  }
  
  // 否则执行全局布局
  return 'global'
}
```

#### 6.2.2 全局布局逻辑
```typescript
function applyGlobalLayout(algorithm: LayoutType) {
  // 1. 获取所有未锁定的顶层节点
  const nodes = graph.getNodes().filter(node => {
    return (
      !node.getParent() &&  // 顶层节点
      !node.getData()?.isManual  // 未锁定
    )
  })
  
  // 2. 获取所有边
  const edges = graph.getEdges()
  
  // 3. 执行布局
  const result = executeLayout(algorithm, nodes, edges)
  
  // 4. 应用新坐标
  applyLayoutResult(result)
}
```

#### 6.2.3 局部布局逻辑
```typescript
function applyLocalLayout(
  container: Node, 
  algorithm: LayoutType
) {
  // 1. 获取容器内所有未锁定的子节点
  const children = container.getChildren()?.filter(child => {
    return !child.getData()?.isManual
  })
  
  if (!children || children.length === 0) {
    return
  }
  
  // 2. 获取子节点间的边（可选）
  const edges = graph.getEdges().filter(edge => {
    const source = edge.getSourceCell()
    const target = edge.getTargetCell()
    return children.includes(source) && children.includes(target)
  })
  
  // 3. 执行布局（坐标是相对容器的）
  const result = executeLayout(algorithm, children, edges)
  
  // 4. 应用新坐标（相对坐标）
  applyLayoutResult(result)
  
  // 5. 触发容器扩容
  expandContainer(container)
}
```

---

## 7. 锁定机制设计

### 7.1 锁定标记

#### 7.1.1 数据模型
在节点数据中添加 `isManual` 字段：
```typescript
interface NodeData {
  // ... 其他字段
  
  // 是否手动布局（锁定位置）
  isManual: boolean
}
```

#### 7.1.2 默认值
- 手动拖拽添加的节点：`isManual: true`
- 自动布局后的节点：`isManual: false`

### 7.2 锁定交互

#### 7.2.1 右键菜单（可选）
- "锁定位置"：设置 `isManual: true`
- "解锁位置"：设置 `isManual: false`

#### 7.2.2 视觉标识
锁定的节点显示锁图标（可选）：
```typescript
// 在节点右上角显示锁图标
if (node.getData()?.isManual) {
  // 添加锁图标标记
}
```

### 7.3 锁定逻辑

#### 7.3.1 过滤锁定节点
```typescript
function getUnlockedNodes(nodes: Node[]): Node[] {
  return nodes.filter(node => !node.getData()?.isManual)
}
```

#### 7.3.2 增量布局
锁定的节点作为"锚点"，未锁定的节点围绕锁定节点布局：
```typescript
function executeIncrementalLayout(
  lockedNodes: Node[],
  unlockedNodes: Node[]
) {
  // 将锁定节点作为固定节点传入布局算法
  const result = layout.layout({
    nodes: [...lockedNodes, ...unlockedNodes],
    edges: graph.getEdges(),
    preset: {
      nodes: lockedNodes.map(n => ({
        id: n.id,
        x: n.position().x,
        y: n.position().y,
        fixed: true  // 固定位置
      }))
    }
  })
  
  // 仅应用未锁定节点的新坐标
  applyLayoutResult(result, unlockedNodes)
}
```

---

## 8. 工具栏集成

### 8.1 布局按钮设计

#### 8.1.1 按钮列表
```typescript
const layoutButtons = [
  {
    id: 'dagre-tb',
    label: 'Dagre 纵向',
    icon: 'Sort',
    algorithm: 'dagre',
    config: { rankdir: 'TB' }
  },
  {
    id: 'dagre-lr',
    label: 'Dagre 横向',
    icon: 'Sort',
    algorithm: 'dagre',
    config: { rankdir: 'LR' }
  },
  {
    id: 'grid',
    label: 'Grid 网格',
    icon: 'Grid',
    algorithm: 'grid',
    config: {}
  }
]
```

#### 8.1.2 按钮交互
- 点击按钮触发布局
- 布局执行中按钮禁用并显示加载状态
- 布局完成后提示成功

### 8.2 布局配置面板（可选）

#### 8.2.1 参数调整
提供弹窗或侧边栏，允许用户调整布局参数：
- 节点间距
- 布局方向
- 对齐方式
- 是否避免重叠

#### 8.2.2 预览功能
布局前预览效果（半透明显示新位置）。

---

## 9. 测试要点

### 9.1 功能测试
- [ ] Dagre 布局正确执行
- [ ] Grid 布局正确执行
- [ ] 全局布局影响所有未锁定节点
- [ ] 局部布局仅影响容器内节点
- [ ] 锁定节点不参与布局
- [ ] 布局后容器自动扩容
- [ ] 布局按钮正确触发

### 9.2 交互测试
- [ ] 布局执行流畅无卡顿
- [ ] 布局过程中可撤销（可选）
- [ ] 布局完成后提示明确
- [ ] 参数调整实时生效（如果有配置面板）

### 9.3 边界测试
- [ ] 空画布执行布局不报错
- [ ] 单个节点执行布局正常
- [ ] 所有节点锁定时布局无效果
- [ ] 大量节点（100+）布局时间可接受

### 9.4 算法测试
- [ ] Dagre 布局层级正确
- [ ] Grid 布局对齐整齐
- [ ] 节点不重叠
- [ ] 边连接正确（如果有边）

---

## 10. 验收标准

### 10.1 功能验收
- ✅ 工具栏有布局按钮
- ✅ 点击按钮能触发布局
- ✅ Dagre 和 Grid 算法都能正常工作
- ✅ 全局布局和局部布局都能正常工作
- ✅ 锁定机制生效
- ✅ 布局后容器自动扩容

### 10.2 性能验收
- ✅ 50 个节点布局时间 < 1s
- ✅ 100 个节点布局时间 < 2s
- ✅ 布局执行不阻塞 UI

### 10.3 代码质量验收
- ✅ 通过 ESLint 检查
- ✅ 通过 TypeScript 编译
- ✅ 布局算法有清晰注释
- ✅ 数据适配器有单元测试

---

## 11. 注意事项

### 11.1 性能优化

#### 11.1.1 异步执行
大量节点时使用 Web Worker 异步计算布局，避免阻塞主线程。

#### 11.1.2 批量更新
布局结果应批量应用到节点，避免逐个更新导致的多次重绘。

### 11.2 用户体验

#### 11.2.1 执行提示
布局执行时显示加载提示，避免用户误以为卡死。

#### 11.2.2 可撤销
提供撤销功能（Ctrl + Z），允许用户恢复布局前的状态。

### 11.3 常见问题

#### Q1: 布局后节点重叠？
**A**: 检查 `preventOverlap` 配置，调整节点间距参数。

#### Q2: Dagre 布局方向错误？
**A**: 检查 `rankdir` 参数是否正确设置。

#### Q3: 局部布局不生效？
**A**: 检查是否正确选中了容器节点，检查子节点是否被锁定。

#### Q4: 布局执行慢？
**A**: 考虑使用 Web Worker 或减少参与布局的节点数量。

### 11.4 开发建议

#### 11.4.1 算法配置化
将布局参数提取为配置文件，方便调整和扩展。

#### 11.4.2 算法扩展
预留接口，方便未来添加更多布局算法。

#### 11.4.3 调试工具
提供布局算法的调试模式，打印中间结果。

---

## 12. 后续步骤预告

完成本步骤后，将进入 **Step 6 - 业务数据扩展**，届时将：
- 实现双击节点触发编辑弹窗
- 扩展节点业务数据模型
- 实现数据持久化（导入/导出 JSON）
- 实现状态视觉反馈

**关键衔接点**：
- 布局算法可能需要考虑业务数据（如节点优先级）
- 业务数据变化可能触发视觉更新

---

**文档版本**：1.0.0  
**创建时间**：2026-02-09  
**预估工时**：2.5 天  
**优先级**：P1（重要但非阻塞）
