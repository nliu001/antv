# Step 4 - 容器自动扩容

## 目录
- [1. 步骤概述](#1-步骤概述)
- [2. 目标与产出](#2-目标与产出)
- [3. 技术方案](#3-技术方案)
- [4. 实现任务拆解](#4-实现任务拆解)
- [5. 包围盒计算](#5-包围盒计算)
- [6. 扩容算法设计](#6-扩容算法设计)
- [7. 性能优化策略](#7-性能优化策略)
- [8. 边界情况处理](#8-边界情况处理)
- [9. 测试要点](#9-测试要点)
- [10. 验收标准](#10-验收标准)
- [11. 注意事项](#11-注意事项)
- [12. 参考资料](#12-参考资料)

---

## 参考资料

### X6 官方文档
- [Node API - position()](https://x6.antv.vision/zh/docs/api/model/node#position)
- [Node API - getBBox()](https://x6.antv.vision/zh/docs/api/model/node#getbbox)
- [Node API - resize()](https://x6.antv.vision/zh/docs/api/model/node#resize)
- [Node API - translate()](https://x6.antv.vision/zh/docs/api/model/node#translate)
- [群组 Group](https://x6.antv.vision/zh/docs/tutorial/basic/group)

### 项目验证文档
- `docs/04-容器自动扩容/X6坐标系统验证报告.md`
- `docs/04-容器自动扩容/验证执行指南.md`
- `docs/04-容器自动扩容/API修正说明.md`
- `docs/04-容器自动扩容/04-容器自动扩容方案重新评估报告.md`

---

## 1. 步骤概述

### 1.1 当前步骤定位
这是图形化布局系统的**第四步**，实现系统容器的**智能自动扩容**功能。容器将根据内部子节点的位置和尺寸动态调整自身大小，同时保持固定的内边距（Padding），确保视觉美观和操作空间。

### 1.2 前置依赖
- ✅ Step 3：拖拽交互已实现
- ✅ 父子关系已建立
- ✅ 坐标转换工具已完成
- ✅ 子节点可入组/出组

### 1.3 后续依赖关系
```
Step 3 (拖拽交互)
    ↓
Step 4 (容器扩容) ← 当前步骤
    ↓ 提供动态容器
Step 5 (布局算法) - 算法后触发扩容
    ↓
Step 6 (业务集成) - 业务数据变化触发扩容
```

---

## 2. 目标与产出

### 2.1 功能目标
- ✅ 监听子节点的位置变化（change:position）
- ✅ 监听子节点的尺寸变化（change:size）
- ✅ 实时计算所有子节点的并集包围盒
- ✅ 动态调整容器尺寸（width、height）
- ✅ 动态调整容器位置（保持子节点相对位置不变）
- ✅ 保持固定的内边距（默认 40px）
- ✅ 空容器时保持最小尺寸
- ✅ 防抖优化避免频繁计算

### 2.2 交付产出
1. **Composable 文件**
   - `src/composables/useAutoExpand.ts` - 自动扩容核心逻辑

2. **工具文件**
   - `src/utils/bboxCalculator.ts` - 包围盒计算工具

3. **配置文件**
   - `src/config/containerConfig.ts` - 容器扩容配置

4. **类型定义**
   - 扩展 `src/types/node.d.ts` - 容器扩容相关类型

---

## 3. 技术方案

### 3.1 技术选型
| 技术项 | 方案 | 理由 |
|--------|------|------|
| 包围盒计算 | graph.getCellsBBox() | X6 原生实例方法，性能优秀 |
| 防抖策略 | lodash-es debounce | 成熟的防抖实现 |
| 事件监听 | X6 事件系统 | 原生支持，响应及时 |
| 节点移动 | translate(dx, dy) | 子节点自动跟随 |
| 尺寸约束 | minWidth/minHeight | 配置化约束 |

### 3.2 架构设计
```
子节点变化（move/resize）
    ↓
X6 Event (node:change:position, node:change:size)
    ↓
useAutoExpand (防抖 100ms)
    ↓
bboxCalculator (计算并集包围盒 - 绝对坐标)
    ↓
计算新位置和尺寸
    ↓
容器位置调整 (translate - 子节点自动跟随)
    ↓
容器尺寸调整 (resize)
    ↓
视图更新
```

### 3.3 扩容流程设计
```
1. 检测触发条件
    ├── 子节点位置变化？
    ├── 子节点尺寸变化？
    ├── 子节点增加？
    └── 子节点删除？
    ↓
2. 防抖等待（100ms）
    ↓
3. 获取所有子节点
    ↓
4. 计算并集包围盒
    ↓
5. 添加内边距
    ↓
6. 应用最小尺寸约束
    ↓
7. 调整容器尺寸
    ↓
8. 调整容器位置（保持子节点视觉位置不变）
    ↓
9. 触发扩容完成事件
```

---

## 4. 实现任务拆解

### 4.1 任务清单
| 任务编号 | 任务名称 | 优先级 | 预估工时 | 依赖 |
|---------|---------|--------|----------|------|
| T4-1 | 创建容器配置文件 | P0 | 0.5h | 无 |
| T4-2 | 实现包围盒计算工具 | P0 | 2h | 无 |
| T4-3 | 实现扩容核心算法 | P0 | 3h | T4-2 |
| T4-4 | 集成防抖优化 | P0 | 1h | T4-3 |
| T4-5 | 处理空容器场景 | P0 | 1h | T4-3 |
| T4-6 | 处理容器移动联动 | P0 | 1.5h | 无 |
| T4-7 | 添加事件监听器 | P0 | 1.5h | T4-4 |
| T4-8 | 扩展 Store 存储扩容配置 | P0 | 0.5h | 无 |
| T4-9 | 测试扩容功能 | P0 | 2h | T4-7 |

**总工时**：约 13 小时（2 个工作日）

### 4.2 实施顺序
```
Phase 1: 基础工具 (T4-1, T4-2)
    ↓
Phase 2: 核心算法 (T4-3, T4-4, T4-5)
    ↓
Phase 3: 事件集成 (T4-6, T4-7)
    ↓
Phase 4: Store 集成 (T4-8)
    ↓
Phase 5: 测试验证 (T4-9)
```

---

## 5. 包围盒计算

### 5.1 基础概念

#### 5.1.1 包围盒（BBox）
包围盒是能够完全包含节点的最小矩形，由以下属性组成：
- `x`：左上角 x 坐标
- `y`：左上角 y 坐标
- `width`：宽度
- `height`：高度

#### 5.1.2 并集包围盒（Union BBox）
多个节点的并集包围盒是能够包含所有这些节点的最小矩形。

### 5.2 计算方法

#### 5.2.1 单个节点包围盒
使用 X6 API 直接获取：
```typescript
const bbox = node.getBBox()
// 返回：{ x, y, width, height }
```

#### 5.2.2 多节点并集包围盒
使用 X6 graph 实例方法：
```typescript
// 注意：graph.getCellsBBox() 是实例方法，不是 Graph 的静态方法
const children = parent.getChildren()
const unionBBox = graph.getCellsBBox(children)
// 返回：{ x, y, width, height } 或 null（当 children 为空时）

// ✅ 坐标说明：
// - unionBBox.x 和 unionBBox.y 是**绝对坐标**（相对于画布）
// - 不需要进行任何坐标转换
```

#### 5.2.3 手动计算并集包围盒
当需要自定义逻辑时：
```typescript
function calculateUnionBBox(nodes: Node[]): BBox {
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 }
  }
  
  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity
  
  nodes.forEach(node => {
    const bbox = node.getBBox()
    minX = Math.min(minX, bbox.x)
    minY = Math.min(minY, bbox.y)
    maxX = Math.max(maxX, bbox.x + bbox.width)
    maxY = Math.max(maxY, bbox.y + bbox.height)
  })
  
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  }
}
```

### 5.3 X6 坐标系统（官方验证）

#### 5.3.1 核心事实

根据 X6 官方文档和实测验证（详见 `docs/04-容器自动扩容/X6坐标系统验证报告.md`）：

1. ✅ `node.getPosition()` 默认返回**绝对坐标**（相对于画布）
2. ✅ `node.getBBox()` 返回的坐标也是**绝对坐标**
3. ✅ `graph.getCellsBBox()` 返回的坐标也是**绝对坐标**
4. ✅ 仅当调用 `position({ relative: true })` 时才返回相对坐标

**重要**：X6 的 `addChild()` **不会改变**子节点的坐标值，子节点始终使用绝对坐标。

#### 5.3.2 官方文档依据

**position() API 文档**：
> | 名称 | 类型 | 必选 | 默认值 | 描述 |
> | --- | --- | --- | --- | --- |
> | options.relative | boolean |  | **false** | 是否返回相对于父节点的相对位置，**默认为 false 表示返回节点相对于画布的绝对位置**。 |

来源：https://x6.antv.vision/zh/docs/api/model/node#position

**群组文档**：
> “需要注意的是，子节点的位置是相对画布左上角的位置，我们并没有提供相对父节点的相对定位方法。”

来源：https://x6.antv.vision/zh/docs/tutorial/basic/group

#### 5.3.3 验证结果

**Q1 验证**（`getBBox()` 坐标系）：
- 容器位置：(100, 100)
- 子节点位置：(150, 150)
- 子节点 `getBBox()`：`{ x: 150, y: 150, ... }`
- **结论**：✅ 返回**绝对坐标**（x = 150，不是相对值 50）

**Q2 验证**（`getCellsBBox()` 坐标系）：
- 容器位置：(100, 100)
- 子节点1：(150, 150)
- 子节点2：(250, 250)
- 并集 `getCellsBBox()`：`{ x: 150, y: 150, width: 150, height: 150 }`
- **结论**：✅ 返回**绝对坐标**（x = 150，不是相对值 50）

#### 5.3.4 实现影响

✅ **好消息**：坐标计算比原方案**更简单**

```typescript
// ✅ 正确做法：直接使用，无需转换
const bbox = node.getBBox()  // 已经是绝对坐标
const unionBBox = graph.getCellsBBox(children)  // 已经是绝对坐标

// ✅ 容器新位置 = 包围盒左上角 - PADDING
const newX = unionBBox.x - PADDING
const newY = unionBBox.y - PADDING

// ✅ 计算偏移量（用于 translate）
const dx = newX - container.getPosition().x
const dy = newY - container.getPosition().y
```

---

## 6. 扩容算法设计

### 6.1 核心算法

#### 6.1.1 算法伪码
```
function autoExpandContainer(container, graph) {
  // 1. 获取所有子节点
  children = container.getChildren()
  
  // 2. 空容器处理
  if (children.length === 0) {
    resize(container, MIN_WIDTH, MIN_HEIGHT)
    return
  }
  
  // 3. 计算并集包围盒（绝对坐标）
  unionBBox = graph.getCellsBBox(children)
  if (!unionBBox) return
  
  // 4. 计算容器新位置（绝对坐标）
  newX = unionBBox.x - PADDING
  newY = unionBBox.y - PADDING
  
  // 5. 计算容器新尺寸
  newWidth = max(unionBBox.width + PADDING * 2, MIN_WIDTH)
  newHeight = max(unionBBox.height + PADDING * 2, MIN_HEIGHT)
  
  // 6. 计算位置偏移量
  oldPos = container.getPosition()
  dx = newX - oldPos.x
  dy = newY - oldPos.y
  
  // 7. 调整容器位置（使用 translate 让子节点自动跟随）
  if (abs(dx) > THRESHOLD || abs(dy) > THRESHOLD) {
    container.translate(dx, dy)  // ✅ 关键：使用 translate()
  }
  
  // 8. 调整容器尺寸
  container.resize(newWidth, newHeight)
}
```

#### 6.1.2 关键参数
```typescript
const EXPAND_CONFIG = {
  // 内边距（四周留白）
  PADDING: 40,
  
  // 最小宽度
  MIN_WIDTH: 200,
  
  // 最小高度
  MIN_HEIGHT: 150,
  
  // 位置调整阈值（小于此值不调整，避免抖动）
  POSITION_THRESHOLD: 5,
  
  // 防抖延迟（毫秒）
  DEBOUNCE_DELAY: 100
}
```

### 6.2 边界情况处理

#### 6.2.1 空容器
```typescript
if (!children || children.length === 0) {
  container.resize(MIN_WIDTH, MIN_HEIGHT)
  // 不调整位置
  return
}
```

#### 6.2.2 单个子节点
```typescript
if (children.length === 1) {
  const childBBox = children[0].getBBox()
  const newWidth = Math.max(childBBox.width + PADDING * 2, MIN_WIDTH)
  const newHeight = Math.max(childBBox.height + PADDING * 2, MIN_HEIGHT)
  
  container.resize(newWidth, newHeight)
  
  // 调整位置使子节点居中
  const offsetX = childBBox.x - PADDING
  const offsetY = childBBox.y - PADDING
  container.translate(-offsetX, -offsetY)
}
```

#### 6.2.3 子节点分散
当子节点分布在容器的不同区域时，包围盒可能很大，需要考虑：
- 是否设置最大尺寸限制（可选）
- 是否警告用户布局过于分散

### 6.3 位置调整策略

#### 6.3.1 为什么需要调整位置？
当子节点移动导致并集包围盒的**左上角坐标**变化时，如果仅调整容器尺寸，会导致子节点的视觉位置发生偏移。因此需要同步调整容器位置。

#### 6.3.2 正确的位置调整算法

**关键知识点**：
1. ✅ `unionBBox.x` 和 `unionBBox.y` 是**绝对坐标**（相对于画布）
2. ✅ 容器新位置 = `unionBBox.x - PADDING`（直接计算，不需要相对转换）
3. ✅ 必须使用 `translate()` 移动容器，才能让子节点自动跟随
4. ✅ **不能使用** `setPosition()` 或 `position()`，否则子节点不会跟随

**完整算法**：
```typescript
// 1. 获取子节点并集包围盒（绝对坐标）
const unionBBox = graph.getCellsBBox(children)
if (!unionBBox) {
  // 空容器处理
  container.resize(MIN_WIDTH, MIN_HEIGHT)
  return
}

// 2. 计算容器新位置（绝对坐标）
const newX = unionBBox.x - PADDING
const newY = unionBBox.y - PADDING

// 3. 计算容器新尺寸
const newWidth = Math.max(unionBBox.width + PADDING * 2, MIN_WIDTH)
const newHeight = Math.max(unionBBox.height + PADDING * 2, MIN_HEIGHT)

// 4. 计算位置偏移量
const oldPos = container.getPosition()
const dx = newX - oldPos.x
const dy = newY - oldPos.y

// 5. 应用位置调整（使用 translate）
if (Math.abs(dx) > THRESHOLD || Math.abs(dy) > THRESHOLD) {
  container.translate(dx, dy)  // ✅ 子节点会自动跟随
}

// 6. 应用尺寸调整
container.resize(newWidth, newHeight)
```

**为什么必须用 translate()？**

根据 X6 官方文档和实测验证（Q3）：
- ✅ `translate(dx, dy)` 会触发 X6 内部的子节点跟随机制
- ❌ `setPosition(x, y)` 不会触发子节点跟随，子节点会“飞出”容器

**验证结果**：
```
使用 container.translate(-20, -20)：
- 容器从 (100, 100) 移动到 (80, 80)
- 子节点从 (150, 150) 自动跟随到 (130, 130) ✅

使用 container.setPosition(80, 80)：
- 容器从 (100, 100) 移动到 (80, 80)
- 子节点保持在 (150, 150) ❌ 没有跟随
```

参考：`docs/04-容器自动扩容/X6坐标系统验证报告.md` 第 4.3 节

#### 6.3.3 translate() vs setPosition()

**关键差异**：

| 方法 | 子节点跟随 | 适用场景 |
|-----|-----------|----------|
| `translate(dx, dy)` | ✅ **会跟随** | 容器扩容、拖拽移动 |
| `setPosition(x, y)` | ❌ **不跟随** | 初始化位置（无子节点时） |
| `position(x, y)` | ❌ **不跟随** | 同 `setPosition` |

**官方文档说明**：
> “当移动父节点时子节点也会跟着移动。实际上，即便子节点位于父节点外部，移动父节点时子节点也将跟着移动。”
>
> 来源：https://x6.antv.vision/zh/docs/tutorial/basic/group

**扩容算法必须使用 translate()**：

```typescript
// ✅ 正确示例
function autoExpandContainer(container: Node, graph: Graph) {
  const unionBBox = graph.getCellsBBox(children)
  const newX = unionBBox.x - PADDING
  const newY = unionBBox.y - PADDING
  
  const oldPos = container.getPosition()
  const dx = newX - oldPos.x
  const dy = newY - oldPos.y
  
  // ✅ 关键：使用 translate()
  container.translate(dx, dy)
  container.resize(newWidth, newHeight)
}

// ❌ 错误示例
function autoExpandContainer(container: Node, graph: Graph) {
  // ...
  // ❌ 使用 setPosition() 会导致子节点飞出
  container.setPosition(newX, newY)  // 子节点不会跟随！
  container.resize(newWidth, newHeight)
}
```

**重要提示**：
- ✅ 这是 X6 的**默认行为**，不需要启用 `embedding` 配置
- ✅ `embedding` 配置仅用于**交互式拖入**创建父子关系，与移动跟随无关

#### 6.3.4 阈值保护
设置 `POSITION_THRESHOLD = 5px`，避免因微小偏移导致的容器抖动。

---

## 7. 性能优化策略

### 7.1 防抖优化

#### 7.1.1 为什么需要防抖？
- 子节点拖拽时会频繁触发 `change:position` 事件
- 每次事件都计算包围盒会导致性能问题
- 防抖可将多次计算合并为一次

#### 7.1.2 防抖实现
```typescript
import { debounce } from 'lodash-es'

const expandContainer = debounce((container: Node) => {
  // 扩容逻辑
}, DEBOUNCE_DELAY)
```

#### 7.1.3 防抖延迟选择
- **100ms**：推荐值，既能减少计算次数，又不影响体验
- **50ms**：更灵敏，但计算次数增加
- **200ms**：计算次数最少，但用户感知延迟明显

### 7.2 事件优化

#### 7.2.1 事件过滤
仅监听容器内子节点的变化，忽略其他节点：
```typescript
graph.on('node:change:position', ({ node }) => {
  const parent = node.getParent()
  if (parent && parent.getData()?.type === NodeType.SYSTEM) {
    expandContainer(parent)
  }
})
```

#### 7.2.2 批量更新
当同时移动多个子节点时，防抖会自动合并为一次更新。

### 7.3 计算优化

#### 7.3.1 缓存包围盒
对于不变的子节点，可缓存其包围盒，避免重复计算。

#### 7.3.2 增量计算
当仅有一个子节点变化时，可基于上次结果进行增量更新，而非全量重算。

---

## 8. 边界情况处理

### 8.1 容器移动联动

#### 8.1.1 需求
容器移动时，所有子节点应随之移动（X6 的 `embedded` 机制自动处理）。

#### 8.1.2 注意事项
- 容器移动**不应触发扩容**
- 需要区分是"用户拖拽容器"还是"扩容算法调整容器位置"

#### 8.1.3 实现方案
```typescript
// 设置标志位，避免递归触发
let isExpandingContainer = false

function expandContainer(container: Node, graph: Graph) {
  isExpandingContainer = true
  
  // 扩容逻辑
  const unionBBox = graph.getCellsBBox(container.getChildren())
  if (!unionBBox) {
    container.resize(MIN_WIDTH, MIN_HEIGHT)
    isExpandingContainer = false
    return
  }
  
  const newX = unionBBox.x - PADDING
  const newY = unionBBox.y - PADDING
  const oldPos = container.getPosition()
  const dx = newX - oldPos.x
  const dy = newY - oldPos.y
  
  // ✅ 关键：使用 translate() 而非 setPosition()
  if (Math.abs(dx) > THRESHOLD || Math.abs(dy) > THRESHOLD) {
    container.translate(dx, dy)
  }
  container.resize(
    Math.max(unionBBox.width + PADDING * 2, MIN_WIDTH),
    Math.max(unionBBox.height + PADDING * 2, MIN_HEIGHT)
  )
  
  isExpandingContainer = false
}

graph.on('node:change:position', ({ node }) => {
  if (isExpandingContainer) return  // 跳过扩容触发的位置变化
  
  const parent = node.getParent()
  if (parent) {
    expandContainer(parent, graph)
  }
})
```

### 8.2 子节点删除

#### 8.2.1 监听删除事件
```typescript
graph.on('node:removed', ({ node }) => {
  const parent = node.getParent()
  if (parent) {
    expandContainer(parent)
  }
})
```

#### 8.2.2 空容器处理
子节点全部删除后，容器应恢复最小尺寸。

### 8.3 容器嵌套（未来扩展）

#### 8.3.1 当前限制
当前版本仅支持**单层嵌套**（设备节点可入组容器，但容器不能入组容器）。

#### 8.3.2 多层嵌套扩展
如果未来支持多层嵌套，需要：
- 递归更新父容器链
- 坐标转换需要遍历父节点链
- 性能优化更加重要

---

## 9. 测试要点

### 9.1 功能测试
- [ ] 拖动单个子节点，容器自动扩容
- [ ] 拖动多个子节点，容器正确包裹
- [ ] 删除子节点，容器自动缩小
- [ ] 删除所有子节点，容器恢复最小尺寸
- [ ] 调整子节点尺寸，容器自动调整
- [ ] 容器移动时子节点跟随

### 9.2 视觉测试
- [ ] 扩容后子节点视觉位置不变
- [ ] 扩容动画流畅（如果有）
- [ ] 内边距保持一致（40px）
- [ ] 最小尺寸约束生效

### 9.3 性能测试
- [ ] 拖拽时无明显卡顿（60 FPS）
- [ ] 防抖生效（100ms 内多次移动仅触发一次扩容）
- [ ] 10 个子节点容器扩容时间 < 50ms
- [ ] 50 个子节点容器扩容时间 < 200ms

### 9.4 边界测试
- [ ] 空容器不报错
- [ ] 单个子节点正确处理
- [ ] 子节点分布极端分散时容器尺寸合理
- [ ] 快速拖拽不触发错误
- [ ] 容器最小尺寸限制生效

---

## 10. 验收标准

### 10.1 功能验收
- ✅ 子节点移动时容器自动扩容
- ✅ 子节点缩放时容器自动调整
- ✅ 子节点删除时容器自动缩小
- ✅ 空容器保持最小尺寸
- ✅ 扩容后子节点位置无跳变
- ✅ 容器移动时子节点正确跟随

### 10.2 性能验收
- ✅ 扩容计算延迟 < 100ms
- ✅ 拖拽流畅度保持 60 FPS
- ✅ 防抖优化生效

### 10.3 代码质量验收
- ✅ 通过 ESLint 检查
- ✅ 通过 TypeScript 编译
- ✅ 包围盒计算有单元测试
- ✅ 扩容算法有清晰注释

---

## 11. 注意事项

### 11.1 性能优化

#### 11.1.1 防抖参数调优
根据实际测试调整 `DEBOUNCE_DELAY`，在响应速度和计算频率之间取得平衡。

#### 11.1.2 避免递归触发
使用标志位防止扩容算法触发的位置变化再次触发扩容。

#### 11.1.3 事件清理
组件销毁时清理所有事件监听器，避免内存泄漏。

### 11.2 交互体验

#### 11.2.1 避免抖动
使用 `POSITION_THRESHOLD` 避免微小偏移导致的容器位置抖动。

#### 11.2.2 动画过渡
可选：为容器尺寸变化添加 CSS 过渡动画（0.2s），使扩容更平滑。

### 11.3 常见问题

#### Q1: 容器频繁抖动？
**A**: 增大 `POSITION_THRESHOLD` 或增加防抖延迟。

#### Q2: 扩容后子节点位置跳变？
**A**: 检查是否使用了 `translate()` 方法。如果使用 `setPosition()` 或 `position()`，子节点不会跟随容器移动，导致视觉上的跳变。必须使用 `translate(dx, dy)` 才能让子节点自动跟随。详见第 6.3.3 节。

#### Q3: 空容器尺寸不正确？
**A**: 检查最小尺寸约束是否生效。

#### Q4: 性能问题？
**A**: 检查防抖是否生效，是否有不必要的全量重算。

### 11.4 开发建议

#### 11.4.1 调试工具
- 在扩容时打印包围盒信息
- 临时显示包围盒边界（调试模式）
- 监控扩容触发频率

#### 11.4.2 配置化
将所有魔法数字（PADDING、MIN_WIDTH 等）提取为配置项，便于调整。

#### 11.4.3 单元测试
为包围盒计算、坐标转换等核心算法编写单元测试。

---

## 12. 后续步骤预告

完成本步骤后，将进入 **Step 5 - 布局算法集成**，届时将：
- 集成 Dagre 层级布局算法
- 集成 Grid 网格布局算法
- 实现局部整理功能
- 实现锁定机制保护手动布局

**关键衔接点**：
- 自动布局后会触发容器扩容
- 扩容逻辑需要兼容布局算法的坐标调整

---

**文档版本**：2.0.0（已修正坐标系统错误）  
**创建时间**：2026-02-09  
**修订时间**：2026-02-10（根据 X6 官方验证修正）  
**预估工时**：2 天  
**优先级**：P0（必须完成）
