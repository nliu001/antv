# Step 4 - 容器自动扩容

## 目录
- [1. 步骤概述](#1-步骤概述)
- [2. 目标与产出](#2-目标与产出)
- [3. 技术方案](#3-技术方案)
- [4. 实现任务拆解](#4-实现任务拆解)
- [5. 包围盒计算](#5-包围盒计算)
- [6. 扩容算法设计](#6-扩容算法设计)
- [7. 性能优化策略](#7-性能优化策略)
- [8. 边界情况处理](#8-边界情况处理)
- [9. 测试要点](#9-测试要点)
- [10. 验收标准](#10-验收标准)
- [11. 注意事项](#11-注意事项)

---

## 1. 步骤概述

### 1.1 当前步骤定位
这是图形化布局系统的**第四步**，实现系统容器的**智能自动扩容**功能。容器将根据内部子节点的位置和尺寸动态调整自身大小，同时保持固定的内边距（Padding），确保视觉美观和操作空间。

### 1.2 前置依赖
- ✅ Step 3：拖拽交互已实现
- ✅ 父子关系已建立
- ✅ 坐标转换工具已完成
- ✅ 子节点可入组/出组

### 1.3 后续依赖关系
```
Step 3 (拖拽交互)
    ↓
Step 4 (容器扩容) ← 当前步骤
    ↓ 提供动态容器
Step 5 (布局算法) - 算法后触发扩容
    ↓
Step 6 (业务集成) - 业务数据变化触发扩容
```

---

## 2. 目标与产出

### 2.1 功能目标
- ✅ 监听子节点的位置变化（change:position）
- ✅ 监听子节点的尺寸变化（change:size）
- ✅ 实时计算所有子节点的并集包围盒
- ✅ 动态调整容器尺寸（width、height）
- ✅ 动态调整容器位置（保持子节点相对位置不变）
- ✅ 保持固定的内边距（默认 40px）
- ✅ 空容器时保持最小尺寸
- ✅ 防抖优化避免频繁计算

### 2.2 交付产出
1. **Composable 文件**
   - `src/composables/useAutoExpand.ts` - 自动扩容核心逻辑

2. **工具文件**
   - `src/utils/bboxCalculator.ts` - 包围盒计算工具

3. **配置文件**
   - `src/config/containerConfig.ts` - 容器扩容配置

4. **类型定义**
   - 扩展 `src/types/node.d.ts` - 容器扩容相关类型

---

## 3. 技术方案

### 3.1 技术选型
| 技术项 | 方案 | 理由 |
|--------|------|------|
| 包围盒计算 | Graph.getCellsBBox() | X6 原生方法，性能优秀 |
| 防抖策略 | lodash-es debounce | 成熟的防抖实现 |
| 事件监听 | X6 事件系统 | 原生支持，响应及时 |
| 尺寸约束 | minWidth/minHeight | 配置化约束 |

### 3.2 架构设计
```
子节点变化（move/resize）
    ↓
X6 Event (node:change:position, node:change:size)
    ↓
useAutoExpand (防抖 100ms)
    ↓
bboxCalculator (计算并集包围盒)
    ↓
容器尺寸调整 (resize + position)
    ↓
视图更新
```

### 3.3 扩容流程设计
```
1. 检测触发条件
    ├── 子节点位置变化？
    ├── 子节点尺寸变化？
    ├── 子节点增加？
    └── 子节点删除？
    ↓
2. 防抖等待（100ms）
    ↓
3. 获取所有子节点
    ↓
4. 计算并集包围盒
    ↓
5. 添加内边距
    ↓
6. 应用最小尺寸约束
    ↓
7. 调整容器尺寸
    ↓
8. 调整容器位置（保持子节点视觉位置不变）
    ↓
9. 触发扩容完成事件
```

---

## 4. 实现任务拆解

### 4.1 任务清单
| 任务编号 | 任务名称 | 优先级 | 预估工时 | 依赖 |
|---------|---------|--------|----------|------|
| T4-1 | 创建容器配置文件 | P0 | 0.5h | 无 |
| T4-2 | 实现包围盒计算工具 | P0 | 2h | 无 |
| T4-3 | 实现扩容核心算法 | P0 | 3h | T4-2 |
| T4-4 | 集成防抖优化 | P0 | 1h | T4-3 |
| T4-5 | 处理空容器场景 | P0 | 1h | T4-3 |
| T4-6 | 处理容器移动联动 | P0 | 1.5h | 无 |
| T4-7 | 添加事件监听器 | P0 | 1.5h | T4-4 |
| T4-8 | 扩展 Store 存储扩容配置 | P0 | 0.5h | 无 |
| T4-9 | 测试扩容功能 | P0 | 2h | T4-7 |

**总工时**：约 13 小时（2 个工作日）

### 4.2 实施顺序
```
Phase 1: 基础工具 (T4-1, T4-2)
    ↓
Phase 2: 核心算法 (T4-3, T4-4, T4-5)
    ↓
Phase 3: 事件集成 (T4-6, T4-7)
    ↓
Phase 4: Store 集成 (T4-8)
    ↓
Phase 5: 测试验证 (T4-9)
```

---

## 5. 包围盒计算

### 5.1 基础概念

#### 5.1.1 包围盒（BBox）
包围盒是能够完全包含节点的最小矩形，由以下属性组成：
- `x`：左上角 x 坐标
- `y`：左上角 y 坐标
- `width`：宽度
- `height`：高度

#### 5.1.2 并集包围盒（Union BBox）
多个节点的并集包围盒是能够包含所有这些节点的最小矩形。

### 5.2 计算方法

#### 5.2.1 单个节点包围盒
使用 X6 API 直接获取：
```typescript
const bbox = node.getBBox()
// 返回：{ x, y, width, height }
```

#### 5.2.2 多节点并集包围盒
使用 X6 工具方法：
```typescript
import { Graph } from '@antv/x6'

const children = parent.getChildren()
const unionBBox = Graph.getCellsBBox(children)
```

#### 5.2.3 手动计算并集包围盒
当需要自定义逻辑时：
```typescript
function calculateUnionBBox(nodes: Node[]): BBox {
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 }
  }
  
  let minX = Infinity
  let minY = Infinity
  let maxX = -Infinity
  let maxY = -Infinity
  
  nodes.forEach(node => {
    const bbox = node.getBBox()
    minX = Math.min(minX, bbox.x)
    minY = Math.min(minY, bbox.y)
    maxX = Math.max(maxX, bbox.x + bbox.width)
    maxY = Math.max(maxY, bbox.y + bbox.height)
  })
  
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  }
}
```

### 5.3 坐标系统注意事项

#### 5.3.1 相对坐标影响
- 子节点的 `getBBox()` 返回的是**相对于父容器**的坐标
- 计算并集包围盒时需要确保坐标系统一致

#### 5.3.2 绝对坐标转换
如果需要绝对坐标：
```typescript
function getAbsoluteBBox(node: Node): BBox {
  const bbox = node.getBBox()
  const parent = node.getParent()
  
  if (!parent) {
    return bbox
  }
  
  const parentPos = parent.position()
  return {
    x: bbox.x + parentPos.x,
    y: bbox.y + parentPos.y,
    width: bbox.width,
    height: bbox.height
  }
}
```

---

## 6. 扩容算法设计

### 6.1 核心算法

#### 6.1.1 算法伪码
```
function autoExpandContainer(container) {
  // 1. 获取所有子节点
  children = container.getChildren()
  
  // 2. 空容器处理
  if (children.length === 0) {
    resize(container, MIN_WIDTH, MIN_HEIGHT)
    return
  }
  
  // 3. 计算并集包围盒
  unionBBox = calculateUnionBBox(children)
  
  // 4. 添加内边距
  newWidth = unionBBox.width + PADDING * 2
  newHeight = unionBBox.height + PADDING * 2
  
  // 5. 应用最小尺寸约束
  newWidth = max(newWidth, MIN_WIDTH)
  newHeight = max(newHeight, MIN_HEIGHT)
  
  // 6. 调整容器尺寸
  container.resize(newWidth, newHeight)
  
  // 7. 调整容器位置（保持子节点视觉位置）
  offsetX = unionBBox.x - PADDING
  offsetY = unionBBox.y - PADDING
  
  if (abs(offsetX) > THRESHOLD || abs(offsetY) > THRESHOLD) {
    currentPos = container.position()
    container.position(
      currentPos.x + offsetX,
      currentPos.y + offsetY
    )
  }
}
```

#### 6.1.2 关键参数
```typescript
const EXPAND_CONFIG = {
  // 内边距（四周留白）
  PADDING: 40,
  
  // 最小宽度
  MIN_WIDTH: 200,
  
  // 最小高度
  MIN_HEIGHT: 150,
  
  // 位置调整阈值（小于此值不调整，避免抖动）
  POSITION_THRESHOLD: 5,
  
  // 防抖延迟（毫秒）
  DEBOUNCE_DELAY: 100
}
```

### 6.2 边界情况处理

#### 6.2.1 空容器
```typescript
if (!children || children.length === 0) {
  container.resize(MIN_WIDTH, MIN_HEIGHT)
  // 不调整位置
  return
}
```

#### 6.2.2 单个子节点
```typescript
if (children.length === 1) {
  const childBBox = children[0].getBBox()
  const newWidth = Math.max(childBBox.width + PADDING * 2, MIN_WIDTH)
  const newHeight = Math.max(childBBox.height + PADDING * 2, MIN_HEIGHT)
  
  container.resize(newWidth, newHeight)
  
  // 调整位置使子节点居中
  const offsetX = childBBox.x - PADDING
  const offsetY = childBBox.y - PADDING
  container.translate(-offsetX, -offsetY)
}
```

#### 6.2.3 子节点分散
当子节点分布在容器的不同区域时，包围盒可能很大，需要考虑：
- 是否设置最大尺寸限制（可选）
- 是否警告用户布局过于分散

### 6.3 位置调整策略

#### 6.3.1 为什么需要调整位置？
当子节点移动导致并集包围盒的**左上角坐标**变化时，如果仅调整容器尺寸，会导致子节点的视觉位置发生偏移。因此需要同步调整容器位置。

#### 6.3.2 调整计算
```typescript
// 计算子节点包围盒相对于容器内部的偏移
const offsetX = unionBBox.x - PADDING
const offsetY = unionBBox.y - PADDING

// 如果偏移超过阈值，调整容器位置
if (Math.abs(offsetX) > THRESHOLD || Math.abs(offsetY) > THRESHOLD) {
  const currentPos = container.position()
  container.position(
    currentPos.x + offsetX,
    currentPos.y + offsetY
  )
}
```

#### 6.3.3 阈值保护
设置 `POSITION_THRESHOLD = 5px`，避免因微小偏移导致的容器抖动。

---

## 7. 性能优化策略

### 7.1 防抖优化

#### 7.1.1 为什么需要防抖？
- 子节点拖拽时会频繁触发 `change:position` 事件
- 每次事件都计算包围盒会导致性能问题
- 防抖可将多次计算合并为一次

#### 7.1.2 防抖实现
```typescript
import { debounce } from 'lodash-es'

const expandContainer = debounce((container: Node) => {
  // 扩容逻辑
}, DEBOUNCE_DELAY)
```

#### 7.1.3 防抖延迟选择
- **100ms**：推荐值，既能减少计算次数，又不影响体验
- **50ms**：更灵敏，但计算次数增加
- **200ms**：计算次数最少，但用户感知延迟明显

### 7.2 事件优化

#### 7.2.1 事件过滤
仅监听容器内子节点的变化，忽略其他节点：
```typescript
graph.on('node:change:position', ({ node }) => {
  const parent = node.getParent()
  if (parent && parent.getData()?.type === NodeType.SYSTEM) {
    expandContainer(parent)
  }
})
```

#### 7.2.2 批量更新
当同时移动多个子节点时，防抖会自动合并为一次更新。

### 7.3 计算优化

#### 7.3.1 缓存包围盒
对于不变的子节点，可缓存其包围盒，避免重复计算。

#### 7.3.2 增量计算
当仅有一个子节点变化时，可基于上次结果进行增量更新，而非全量重算。

---

## 8. 边界情况处理

### 8.1 容器移动联动

#### 8.1.1 需求
容器移动时，所有子节点应随之移动（X6 的 `embedded` 机制自动处理）。

#### 8.1.2 注意事项
- 容器移动**不应触发扩容**
- 需要区分是"用户拖拽容器"还是"扩容算法调整容器位置"

#### 8.1.3 实现方案
```typescript
// 设置标志位，避免递归触发
let isExpandingContainer = false

function expandContainer(container: Node) {
  isExpandingContainer = true
  
  // 扩容逻辑
  container.resize(...)
  container.position(...)
  
  isExpandingContainer = false
}

graph.on('node:change:position', ({ node }) => {
  if (isExpandingContainer) return  // 跳过扩容触发的位置变化
  
  const parent = node.getParent()
  if (parent) {
    expandContainer(parent)
  }
})
```

### 8.2 子节点删除

#### 8.2.1 监听删除事件
```typescript
graph.on('node:removed', ({ node }) => {
  const parent = node.getParent()
  if (parent) {
    expandContainer(parent)
  }
})
```

#### 8.2.2 空容器处理
子节点全部删除后，容器应恢复最小尺寸。

### 8.3 容器嵌套（未来扩展）

#### 8.3.1 当前限制
当前版本仅支持**单层嵌套**（设备节点可入组容器，但容器不能入组容器）。

#### 8.3.2 多层嵌套扩展
如果未来支持多层嵌套，需要：
- 递归更新父容器链
- 坐标转换需要遍历父节点链
- 性能优化更加重要

---

## 9. 测试要点

### 9.1 功能测试
- [ ] 拖动单个子节点，容器自动扩容
- [ ] 拖动多个子节点，容器正确包裹
- [ ] 删除子节点，容器自动缩小
- [ ] 删除所有子节点，容器恢复最小尺寸
- [ ] 调整子节点尺寸，容器自动调整
- [ ] 容器移动时子节点跟随

### 9.2 视觉测试
- [ ] 扩容后子节点视觉位置不变
- [ ] 扩容动画流畅（如果有）
- [ ] 内边距保持一致（40px）
- [ ] 最小尺寸约束生效

### 9.3 性能测试
- [ ] 拖拽时无明显卡顿（60 FPS）
- [ ] 防抖生效（100ms 内多次移动仅触发一次扩容）
- [ ] 10 个子节点容器扩容时间 < 50ms
- [ ] 50 个子节点容器扩容时间 < 200ms

### 9.4 边界测试
- [ ] 空容器不报错
- [ ] 单个子节点正确处理
- [ ] 子节点分布极端分散时容器尺寸合理
- [ ] 快速拖拽不触发错误
- [ ] 容器最小尺寸限制生效

---

## 10. 验收标准

### 10.1 功能验收
- ✅ 子节点移动时容器自动扩容
- ✅ 子节点缩放时容器自动调整
- ✅ 子节点删除时容器自动缩小
- ✅ 空容器保持最小尺寸
- ✅ 扩容后子节点位置无跳变
- ✅ 容器移动时子节点正确跟随

### 10.2 性能验收
- ✅ 扩容计算延迟 < 100ms
- ✅ 拖拽流畅度保持 60 FPS
- ✅ 防抖优化生效

### 10.3 代码质量验收
- ✅ 通过 ESLint 检查
- ✅ 通过 TypeScript 编译
- ✅ 包围盒计算有单元测试
- ✅ 扩容算法有清晰注释

---

## 11. 注意事项

### 11.1 性能优化

#### 11.1.1 防抖参数调优
根据实际测试调整 `DEBOUNCE_DELAY`，在响应速度和计算频率之间取得平衡。

#### 11.1.2 避免递归触发
使用标志位防止扩容算法触发的位置变化再次触发扩容。

#### 11.1.3 事件清理
组件销毁时清理所有事件监听器，避免内存泄漏。

### 11.2 交互体验

#### 11.2.1 避免抖动
使用 `POSITION_THRESHOLD` 避免微小偏移导致的容器位置抖动。

#### 11.2.2 动画过渡
可选：为容器尺寸变化添加 CSS 过渡动画（0.2s），使扩容更平滑。

### 11.3 常见问题

#### Q1: 容器频繁抖动？
**A**: 增大 `POSITION_THRESHOLD` 或增加防抖延迟。

#### Q2: 扩容后子节点位置跳变？
**A**: 检查坐标转换逻辑，确保调整容器位置时同步更新。

#### Q3: 空容器尺寸不正确？
**A**: 检查最小尺寸约束是否生效。

#### Q4: 性能问题？
**A**: 检查防抖是否生效，是否有不必要的全量重算。

### 11.4 开发建议

#### 11.4.1 调试工具
- 在扩容时打印包围盒信息
- 临时显示包围盒边界（调试模式）
- 监控扩容触发频率

#### 11.4.2 配置化
将所有魔法数字（PADDING、MIN_WIDTH 等）提取为配置项，便于调整。

#### 11.4.3 单元测试
为包围盒计算、坐标转换等核心算法编写单元测试。

---

## 12. 后续步骤预告

完成本步骤后，将进入 **Step 5 - 布局算法集成**，届时将：
- 集成 Dagre 层级布局算法
- 集成 Grid 网格布局算法
- 实现局部整理功能
- 实现锁定机制保护手动布局

**关键衔接点**：
- 自动布局后会触发容器扩容
- 扩容逻辑需要兼容布局算法的坐标调整

---

**文档版本**：1.0.0  
**创建时间**：2026-02-09  
**预估工时**：2 天  
**优先级**：P0（必须完成）
